package net.liam.biomsofinfinity.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonIOException;
import com.google.gson.stream.JsonReader;
import net.fabricmc.loader.api.FabricLoader;
import net.liam.biomsofinfinity.Biomsofinfinity;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * Central configuration loader for Bioms of Infinity.
 * <p>
 * The config file lives in {@code config/biomsofinfinity.json5} and is parsed with a lenient GSON reader so that
 * comments and trailing commas survive. The structure mirrors the JSON layout described in the project brief.
 * Call {@link #load()} during mod init and {@link #save()} whenever defaults need to be written.
 */
public final class BOIConfig {

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .disableHtmlEscaping()
            .create();

    private static ConfigData current = new ConfigData();

    private BOIConfig() {
    }

    /**
     * Returns the currently loaded config snapshot.
     */
    public static ConfigData get() {
        return current;
    }

    /**
     * Loads the config file from disk or writes the default template if it does not yet exist.
     */
    public static void load() {
        Path configDir = FabricLoader.getInstance().getConfigDir();
        Path configFile = configDir.resolve("biomsofinfinity.json5");

        if (Files.notExists(configFile)) {
            current = new ConfigData();
            saveInternal(configFile, current, true);
            return;
        }

        try (Reader reader = new BufferedReader(new InputStreamReader(Files.newInputStream(configFile),
                StandardCharsets.UTF_8))) {
            JsonReader jsonReader = new JsonReader(reader);
            jsonReader.setLenient(true);
            ConfigData loaded = GSON.fromJson(jsonReader, ConfigData.class);
            if (loaded == null) {
                Biomsofinfinity.LOGGER.warn("Config file {} was empty – falling back to defaults", configFile);
                current = new ConfigData();
                saveInternal(configFile, current, false);
            } else {
                current = loaded;
            }
        } catch (IOException | JsonIOException ex) {
            Biomsofinfinity.LOGGER.error("Failed to read config file {} – keeping previous values", configFile, ex);
        }
    }

    /**
     * Persists the current configuration back to disk.
     */
    public static void save() {
        Path configDir = FabricLoader.getInstance().getConfigDir();
        Path configFile = configDir.resolve("biomsofinfinity.json5");
        saveInternal(configFile, current, false);
    }

    private static void saveInternal(Path path, ConfigData data, boolean markGenerated) {
        try {
            Files.createDirectories(path.getParent());
            try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(path),
                    StandardCharsets.UTF_8))) {
                if (markGenerated) {
                    writer.write("// Generated by Bioms of Infinity on " + Instant.now() + "\n");
                    writer.write("// Feel free to tweak values – reload in-game via /boi config reload.\n");
                }
                GSON.toJson(data, writer);
            }
        } catch (IOException ex) {
            Biomsofinfinity.LOGGER.error("Failed to write config file {}", path, ex);
        }
    }

    /**
     * Replaces the currently loaded config instance and writes it to disk.
     */
    public static void replace(ConfigData newConfig) {
        current = newConfig == null ? new ConfigData() : newConfig;
        save();
    }

    /**
     * Serializable POJO representing the config layout.
     */
    public static final class ConfigData {
        public Worldgen worldgen = new Worldgen();
        public Bosses bosses = new Bosses();
        public Gameplay gameplay = new Gameplay();
        public Debug debug = new Debug();
    }

    public static final class Worldgen {
        public boolean enableAllBiomes = true;
        public Map<String, Integer> biomeWeights = defaultBiomeWeights();
        public Map<String, Integer> structureWeights = defaultStructureWeights();
    }

    public static final class Bosses {
        public boolean allowBossSpawns = true;
        public boolean naturalBossSpawns = false;
        public boolean altarSpawnsOnly = true;
        public Cooldowns cooldowns = new Cooldowns();
        public int maxConcurrentBosses = 1;
        public boolean announceBossEvents = true;
    }

    public static final class Cooldowns {
        public int globalDays = 7;
        public int perBossDays = 20;
    }

    public static final class Gameplay {
        public boolean aetherSlowFallingInBiome = true;
        public int stormProjectileShieldTicks = 60;
    }

    public static final class Debug {
        public boolean logAllRegistrations = false;
        public boolean datagenForce = false;
    }

    private static Map<String, Integer> defaultBiomeWeights() {
        Map<String, Integer> weights = new HashMap<>();
        weights.put("glowshroom_forest", 8);
        weights.put("floating_gardens", 6);
        weights.put("shadow_isles", 3);
        weights.put("mist_peaks", 4);
        weights.put("crystal_grove", 4);
        return weights;
    }

    private static Map<String, Integer> defaultStructureWeights() {
        Map<String, Integer> weights = new HashMap<>();
        weights.put("crystal_tower", 3);
        weights.put("lost_temple", 1);
        weights.put("mist_ruins", 2);
        weights.put("shadow_altar", 1);
        return weights;
    }
}
